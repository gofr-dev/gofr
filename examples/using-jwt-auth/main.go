package main

import (
	"crypto/rsa"
	"crypto/x509"
	"encoding/base64" 
	"encoding/pem" 
	"fmt"
	"log"        
	"math/big"   
	"net/http"   
	"os"

	"github.com/golang-jwt/jwt/v5"
	"gofr.dev/pkg/gofr"
	"gofr.dev/examples/using-jwt-auth/handler"
)

// Global variables to hold the loaded keys
var (
	rsaPrivateKey *rsa.PrivateKey
	rsaPublicKey  *rsa.PublicKey
)

// init function to load keys at application startup
func init() {
	var err error
	// CRITICAL: These files MUST exist in the 'keys' directory relative to where main.go is run.
	rsaPrivateKey, err = loadRSAPrivateKey("keys/private.pem")
	if err != nil {
		log.Fatalf("Fatal: Failed to load RSA private key: %v", err) // App will crash here if not found/invalid
	}
	rsaPublicKey, err = loadRSAPublicKey("keys/public.pem")
	if err != nil {
		log.Fatalf("Fatal: Failed to load RSA public key: %v", err) // App will crash here if not found/invalid
	}
}

// loadRSAPrivateKey loads an RSA private key from a PEM file.
func loadRSAPrivateKey(filePath string) (*rsa.PrivateKey, error) {
	privateKeyPEM, err := os.ReadFile(filePath)
	if err != nil {
		return nil, fmt.Errorf("failed to read private key file '%s': %w", filePath, err)
	}

	block, _ := pem.Decode(privateKeyPEM)
	if block == nil || block.Type != "RSA PRIVATE KEY" {
		return nil, fmt.Errorf("failed to decode PEM block for private key or invalid type")
	}

	privateKey, err := x509.ParsePKCS1PrivateKey(block.Bytes)
	if err != nil {
		// Try parsing as PKCS8 for compatibility (e.g., if generated by some tools)
		if pkcs8Key, err := x509.ParsePKCS8PrivateKey(block.Bytes); err == nil {
			if rsaPK, ok := pkcs8Key.(*rsa.PrivateKey); ok {
				return rsaPK, nil
			}
		}
		return nil, fmt.Errorf("failed to parse private key: %w", err)
	}
	return privateKey, nil
}

// loadRSAPublicKey loads an RSA public key from a PEM file.
func loadRSAPublicKey(filePath string) (*rsa.PublicKey, error) {
	publicKeyPEM, err := os.ReadFile(filePath)
	if err != nil {
		return nil, fmt.Errorf("failed to read public key file '%s': %w", filePath, err)
	}

	block, _ := pem.Decode(publicKeyPEM)
	if block == nil || block.Type != "PUBLIC KEY" {
		return nil, fmt.Errorf("failed to decode PEM block for public key or invalid type")
	}

	publicKey, err := x509.ParsePKIXPublicKey(block.Bytes)
	if err != nil {
		return nil, fmt.Errorf("failed to parse public key: %w", err)
	}

	rsaPub, ok := publicKey.(*rsa.PublicKey)
	if !ok {
		return nil, fmt.Errorf("public key is not of type RSA")
	}
	return rsaPub, nil
}

// CustomInternalServerError defines a custom error for internal server errors
type CustomInternalServerError struct {
	Message string
}

func (e CustomInternalServerError) Error() string {
	return e.Message
}

func (e CustomInternalServerError) StatusCode() int {
	return http.StatusInternalServerError
}

// JWKSHandler serves the public key in JWKS format.
// For simplicity, we hardcode the key ID (kid) here. In production, this often maps to a key version.
func JWKSHandler(ctx *gofr.Context) (interface{}, error) {
	if rsaPublicKey == nil {
		ctx.Logger.Errorf("JWKSHandler: RSA Public Key not loaded.")
		// FIXED: Use GoFr's custom error handling
		return nil, CustomInternalServerError{Message: "Public key not available"}
	}

	// Calculate modulus and exponent from public key
	n := rsaPublicKey.N
	e := rsaPublicKey.E

	// JWKS format requires modulus (n) and exponent (e) as URL-safe base64 encoded strings.
	// Use base64.RawURLEncoding for this.
	jwks := map[string]interface{}{
		"keys": []map[string]string{
			{
				"kty": "RSA",         // Key Type: RSA
				"use": "sig",         // Public Key Use: For signing
				"kid": "my-rsa-key",  // Key ID: Unique identifier for the key (can be dynamic in production)
				"alg": "RS256",       // Algorithm: RS256
				// CORRECTED: Use base64.RawURLEncoding.EncodeToString
				"n":   base64.RawURLEncoding.EncodeToString(n.Bytes()),
				"e":   base64.RawURLEncoding.EncodeToString(big.NewInt(int64(e)).Bytes()),
			},
		},
	}

	// Simply return the data. GoFr will default to 200 OK for successful handler returns.
	// If you explicitly want to set headers, you can use ctx.Response().SetHeader()
	return jwks, nil
}

func main() {
	app := gofr.New()

	// Public route: Issues JWT token, now signing with RS256 using the loaded private key
	app.POST("/login", handler.LoginHandler(rsaPrivateKey))

	// Register the JWKS endpoint
	// This URL will be used by app.EnableOAuth() to fetch the public key for verification.
	app.GET("/oauth2/jwks", JWKSHandler)

	// Configure GoFr's built-in OAuth/JWT authentication.
	// It will now fetch the public key from the /oauth2/jwks endpoint to verify tokens.
	app.EnableOAuth(
		"http://localhost:8000/oauth2/jwks", // JWKS endpoint URL (adjust port if different)
		60,                                 // Refresh interval in seconds (e.g., 60 seconds)
		jwt.WithExpirationRequired(),       // Enforce presence of 'exp' claim
		// No longer need jwt.WithKeyfunc as EnableOAuth will use JWKS to get keys
	)

	// Secure route: Protected by app.EnableOAuth()
	app.GET("/secure", handler.SecureHandler)

	// Start the application
	// Ensure your application runs on port 8000 (or adjust JWKS endpoint URL above)
	app.Run()
}