// Code generated by MockGen. DO NOT EDIT.
// Source: interface.go
//
// Generated by this command:
//
//	mockgen -source=interface.go -destination=mock_interface.go -package=migration
//
package migration

import (
	context "context"
	sql "database/sql"
	reflect "reflect"
	time "time"

	redis "github.com/redis/go-redis/v9"
	gomock "go.uber.org/mock/gomock"
	container "gofr.dev/pkg/gofr/container"
)

// MockRedis is a mock of Redis interface.
type MockRedis struct {
	ctrl     *gomock.Controller
	recorder *MockRedisMockRecorder
}

// MockRedisMockRecorder is the mock recorder for MockRedis.
type MockRedisMockRecorder struct {
	mock *MockRedis
}

// NewMockRedis creates a new mock instance.
func NewMockRedis(ctrl *gomock.Controller) *MockRedis {
	mock := &MockRedis{ctrl: ctrl}
	mock.recorder = &MockRedisMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockRedis) EXPECT() *MockRedisMockRecorder {
	return m.recorder
}

// Del mocks base method.
func (m *MockRedis) Del(ctx context.Context, keys ...string) *redis.IntCmd {
	m.ctrl.T.Helper()
	varargs := []interface{}{ctx}
	for _, a := range keys {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Del", varargs...)
	ret0, _ := ret[0].(*redis.IntCmd)
	return ret0
}

// Del indicates an expected call of Del.
func (mr *MockRedisMockRecorder) Del(ctx interface{}, keys ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{ctx}, keys...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Del", reflect.TypeOf((*MockRedis)(nil).Del), varargs...)
}

// Get mocks base method.
func (m *MockRedis) Get(ctx context.Context, key string) *redis.StringCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Get", ctx, key)
	ret0, _ := ret[0].(*redis.StringCmd)
	return ret0
}

// Get indicates an expected call of Get.
func (mr *MockRedisMockRecorder) Get(ctx, key interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Get", reflect.TypeOf((*MockRedis)(nil).Get), ctx, key)
}

// Rename mocks base method.
func (m *MockRedis) Rename(ctx context.Context, key, newKey string) *redis.StatusCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Rename", ctx, key, newKey)
	ret0, _ := ret[0].(*redis.StatusCmd)
	return ret0
}

// Rename indicates an expected call of Rename.
func (mr *MockRedisMockRecorder) Rename(ctx, key, newKey interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Rename", reflect.TypeOf((*MockRedis)(nil).Rename), ctx, key, newKey)
}

// Set mocks base method.
func (m *MockRedis) Set(ctx context.Context, key string, value any, expiration time.Duration) *redis.StatusCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Set", ctx, key, value, expiration)
	ret0, _ := ret[0].(*redis.StatusCmd)
	return ret0
}

// Set indicates an expected call of Set.
func (mr *MockRedisMockRecorder) Set(ctx, key, value, expiration interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Set", reflect.TypeOf((*MockRedis)(nil).Set), ctx, key, value, expiration)
}

// MockSQL is a mock of SQL interface.
type MockSQL struct {
	ctrl     *gomock.Controller
	recorder *MockSQLMockRecorder
}

// MockSQLMockRecorder is the mock recorder for MockSQL.
type MockSQLMockRecorder struct {
	mock *MockSQL
}

// NewMockSQL creates a new mock instance.
func NewMockSQL(ctrl *gomock.Controller) *MockSQL {
	mock := &MockSQL{ctrl: ctrl}
	mock.recorder = &MockSQLMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockSQL) EXPECT() *MockSQLMockRecorder {
	return m.recorder
}

// Exec mocks base method.
func (m *MockSQL) Exec(query string, args ...any) (sql.Result, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{query}
	for _, a := range args {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Exec", varargs...)
	ret0, _ := ret[0].(sql.Result)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Exec indicates an expected call of Exec.
func (mr *MockSQLMockRecorder) Exec(query interface{}, args ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{query}, args...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Exec", reflect.TypeOf((*MockSQL)(nil).Exec), varargs...)
}

// ExecContext mocks base method.
func (m *MockSQL) ExecContext(ctx context.Context, query string, args ...any) (sql.Result, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{ctx, query}
	for _, a := range args {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ExecContext", varargs...)
	ret0, _ := ret[0].(sql.Result)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ExecContext indicates an expected call of ExecContext.
func (mr *MockSQLMockRecorder) ExecContext(ctx, query interface{}, args ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{ctx, query}, args...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ExecContext", reflect.TypeOf((*MockSQL)(nil).ExecContext), varargs...)
}

// Query mocks base method.
func (m *MockSQL) Query(query string, args ...any) (*sql.Rows, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{query}
	for _, a := range args {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Query", varargs...)
	ret0, _ := ret[0].(*sql.Rows)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Query indicates an expected call of Query.
func (mr *MockSQLMockRecorder) Query(query interface{}, args ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{query}, args...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Query", reflect.TypeOf((*MockSQL)(nil).Query), varargs...)
}

// QueryRow mocks base method.
func (m *MockSQL) QueryRow(query string, args ...any) *sql.Row {
	m.ctrl.T.Helper()
	varargs := []interface{}{query}
	for _, a := range args {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "QueryRow", varargs...)
	ret0, _ := ret[0].(*sql.Row)
	return ret0
}

// QueryRow indicates an expected call of QueryRow.
func (mr *MockSQLMockRecorder) QueryRow(query interface{}, args ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{query}, args...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "QueryRow", reflect.TypeOf((*MockSQL)(nil).QueryRow), varargs...)
}

// QueryRowContext mocks base method.
func (m *MockSQL) QueryRowContext(ctx context.Context, query string, args ...any) *sql.Row {
	m.ctrl.T.Helper()
	varargs := []interface{}{ctx, query}
	for _, a := range args {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "QueryRowContext", varargs...)
	ret0, _ := ret[0].(*sql.Row)
	return ret0
}

// QueryRowContext indicates an expected call of QueryRowContext.
func (mr *MockSQLMockRecorder) QueryRowContext(ctx, query interface{}, args ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{ctx, query}, args...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "QueryRowContext", reflect.TypeOf((*MockSQL)(nil).QueryRowContext), varargs...)
}

// MockPubSub is a mock of PubSub interface.
type MockPubSub struct {
	ctrl     *gomock.Controller
	recorder *MockPubSubMockRecorder
}

// MockPubSubMockRecorder is the mock recorder for MockPubSub.
type MockPubSubMockRecorder struct {
	mock *MockPubSub
}

// NewMockPubSub creates a new mock instance.
func NewMockPubSub(ctrl *gomock.Controller) *MockPubSub {
	mock := &MockPubSub{ctrl: ctrl}
	mock.recorder = &MockPubSubMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockPubSub) EXPECT() *MockPubSubMockRecorder {
	return m.recorder
}

// CreateTopic mocks base method.
func (m *MockPubSub) CreateTopic(context context.Context, name string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CreateTopic", context, name)
	ret0, _ := ret[0].(error)
	return ret0
}

// CreateTopic indicates an expected call of CreateTopic.
func (mr *MockPubSubMockRecorder) CreateTopic(context, name interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CreateTopic", reflect.TypeOf((*MockPubSub)(nil).CreateTopic), context, name)
}

// DeleteTopic mocks base method.
func (m *MockPubSub) DeleteTopic(context context.Context, name string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "DeleteTopic", context, name)
	ret0, _ := ret[0].(error)
	return ret0
}

// DeleteTopic indicates an expected call of DeleteTopic.
func (mr *MockPubSubMockRecorder) DeleteTopic(context, name interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DeleteTopic", reflect.TypeOf((*MockPubSub)(nil).DeleteTopic), context, name)
}

// MockClickhouse is a mock of Clickhouse interface.
type MockClickhouse struct {
	ctrl     *gomock.Controller
	recorder *MockClickhouseMockRecorder
}

// MockClickhouseMockRecorder is the mock recorder for MockClickhouse.
type MockClickhouseMockRecorder struct {
	mock *MockClickhouse
}

// NewMockClickhouse creates a new mock instance.
func NewMockClickhouse(ctrl *gomock.Controller) *MockClickhouse {
	mock := &MockClickhouse{ctrl: ctrl}
	mock.recorder = &MockClickhouseMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockClickhouse) EXPECT() *MockClickhouseMockRecorder {
	return m.recorder
}

// AsyncInsert mocks base method.
func (m *MockClickhouse) AsyncInsert(ctx context.Context, query string, wait bool, args ...any) error {
	m.ctrl.T.Helper()
	varargs := []interface{}{ctx, query, wait}
	for _, a := range args {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "AsyncInsert", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// AsyncInsert indicates an expected call of AsyncInsert.
func (mr *MockClickhouseMockRecorder) AsyncInsert(ctx, query, wait interface{}, args ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{ctx, query, wait}, args...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AsyncInsert", reflect.TypeOf((*MockClickhouse)(nil).AsyncInsert), varargs...)
}

// Exec mocks base method.
func (m *MockClickhouse) Exec(ctx context.Context, query string, args ...any) error {
	m.ctrl.T.Helper()
	varargs := []interface{}{ctx, query}
	for _, a := range args {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Exec", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// Exec indicates an expected call of Exec.
func (mr *MockClickhouseMockRecorder) Exec(ctx, query interface{}, args ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{ctx, query}, args...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Exec", reflect.TypeOf((*MockClickhouse)(nil).Exec), varargs...)
}

// HealthCheck mocks base method.
func (m *MockClickhouse) HealthCheck(ctx context.Context) (any, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "HealthCheck", ctx)
	ret0, _ := ret[0].(any)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// HealthCheck indicates an expected call of HealthCheck.
func (mr *MockClickhouseMockRecorder) HealthCheck(ctx interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "HealthCheck", reflect.TypeOf((*MockClickhouse)(nil).HealthCheck), ctx)
}

// Select mocks base method.
func (m *MockClickhouse) Select(ctx context.Context, dest any, query string, args ...any) error {
	m.ctrl.T.Helper()
	varargs := []interface{}{ctx, dest, query}
	for _, a := range args {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Select", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// Select indicates an expected call of Select.
func (mr *MockClickhouseMockRecorder) Select(ctx, dest, query interface{}, args ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{ctx, dest, query}, args...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Select", reflect.TypeOf((*MockClickhouse)(nil).Select), varargs...)
}

// MockCassandra is a mock of Cassandra interface.
type MockCassandra struct {
	ctrl     *gomock.Controller
	recorder *MockCassandraMockRecorder
}

// MockCassandraMockRecorder is the mock recorder for MockCassandra.
type MockCassandraMockRecorder struct {
	mock *MockCassandra
}

// NewMockCassandra creates a new mock instance.
func NewMockCassandra(ctrl *gomock.Controller) *MockCassandra {
	mock := &MockCassandra{ctrl: ctrl}
	mock.recorder = &MockCassandraMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockCassandra) EXPECT() *MockCassandraMockRecorder {
	return m.recorder
}

// BatchQuery mocks base method.
func (m *MockCassandra) BatchQuery(name, stmt string, values ...any) error {
	m.ctrl.T.Helper()
	varargs := []interface{}{name, stmt}
	for _, a := range values {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "BatchQuery", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// BatchQuery indicates an expected call of BatchQuery.
func (mr *MockCassandraMockRecorder) BatchQuery(name, stmt interface{}, values ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{name, stmt}, values...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "BatchQuery", reflect.TypeOf((*MockCassandra)(nil).BatchQuery), varargs...)
}

// Exec mocks base method.
func (m *MockCassandra) Exec(query string, args ...any) error {
	m.ctrl.T.Helper()
	varargs := []interface{}{query}
	for _, a := range args {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Exec", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// Exec indicates an expected call of Exec.
func (mr *MockCassandraMockRecorder) Exec(query interface{}, args ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{query}, args...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Exec", reflect.TypeOf((*MockCassandra)(nil).Exec), varargs...)
}

// ExecuteBatch mocks base method.
func (m *MockCassandra) ExecuteBatch(name string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ExecuteBatch", name)
	ret0, _ := ret[0].(error)
	return ret0
}

// ExecuteBatch indicates an expected call of ExecuteBatch.
func (mr *MockCassandraMockRecorder) ExecuteBatch(name interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ExecuteBatch", reflect.TypeOf((*MockCassandra)(nil).ExecuteBatch), name)
}

// HealthCheck mocks base method.
func (m *MockCassandra) HealthCheck(ctx context.Context) (any, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "HealthCheck", ctx)
	ret0, _ := ret[0].(any)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// HealthCheck indicates an expected call of HealthCheck.
func (mr *MockCassandraMockRecorder) HealthCheck(ctx interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "HealthCheck", reflect.TypeOf((*MockCassandra)(nil).HealthCheck), ctx)
}

// NewBatch mocks base method.
func (m *MockCassandra) NewBatch(name string, batchType int) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "NewBatch", name, batchType)
	ret0, _ := ret[0].(error)
	return ret0
}

// NewBatch indicates an expected call of NewBatch.
func (mr *MockCassandraMockRecorder) NewBatch(name, batchType interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "NewBatch", reflect.TypeOf((*MockCassandra)(nil).NewBatch), name, batchType)
}

// MockMongo is a mock of Mongo interface.
type MockMongo struct {
	ctrl     *gomock.Controller
	recorder *MockMongoMockRecorder
}

// MockMongoMockRecorder is the mock recorder for MockMongo.
type MockMongoMockRecorder struct {
	mock *MockMongo
}

// NewMockMongo creates a new mock instance.
func NewMockMongo(ctrl *gomock.Controller) *MockMongo {
	mock := &MockMongo{ctrl: ctrl}
	mock.recorder = &MockMongoMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockMongo) EXPECT() *MockMongoMockRecorder {
	return m.recorder
}

// CreateCollection mocks base method.
func (m *MockMongo) CreateCollection(ctx context.Context, name string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CreateCollection", ctx, name)
	ret0, _ := ret[0].(error)
	return ret0
}

// CreateCollection indicates an expected call of CreateCollection.
func (mr *MockMongoMockRecorder) CreateCollection(ctx, name interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CreateCollection", reflect.TypeOf((*MockMongo)(nil).CreateCollection), ctx, name)
}

// DeleteMany mocks base method.
func (m *MockMongo) DeleteMany(ctx context.Context, collection string, filter any) (int64, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "DeleteMany", ctx, collection, filter)
	ret0, _ := ret[0].(int64)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// DeleteMany indicates an expected call of DeleteMany.
func (mr *MockMongoMockRecorder) DeleteMany(ctx, collection, filter interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DeleteMany", reflect.TypeOf((*MockMongo)(nil).DeleteMany), ctx, collection, filter)
}

// DeleteOne mocks base method.
func (m *MockMongo) DeleteOne(ctx context.Context, collection string, filter any) (int64, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "DeleteOne", ctx, collection, filter)
	ret0, _ := ret[0].(int64)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// DeleteOne indicates an expected call of DeleteOne.
func (mr *MockMongoMockRecorder) DeleteOne(ctx, collection, filter interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DeleteOne", reflect.TypeOf((*MockMongo)(nil).DeleteOne), ctx, collection, filter)
}

// Drop mocks base method.
func (m *MockMongo) Drop(ctx context.Context, collection string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Drop", ctx, collection)
	ret0, _ := ret[0].(error)
	return ret0
}

// Drop indicates an expected call of Drop.
func (mr *MockMongoMockRecorder) Drop(ctx, collection interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Drop", reflect.TypeOf((*MockMongo)(nil).Drop), ctx, collection)
}

// Find mocks base method.
func (m *MockMongo) Find(ctx context.Context, collection string, filter, results any) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Find", ctx, collection, filter, results)
	ret0, _ := ret[0].(error)
	return ret0
}

// Find indicates an expected call of Find.
func (mr *MockMongoMockRecorder) Find(ctx, collection, filter, results interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Find", reflect.TypeOf((*MockMongo)(nil).Find), ctx, collection, filter, results)
}

// FindOne mocks base method.
func (m *MockMongo) FindOne(ctx context.Context, collection string, filter, result any) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "FindOne", ctx, collection, filter, result)
	ret0, _ := ret[0].(error)
	return ret0
}

// FindOne indicates an expected call of FindOne.
func (mr *MockMongoMockRecorder) FindOne(ctx, collection, filter, result interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FindOne", reflect.TypeOf((*MockMongo)(nil).FindOne), ctx, collection, filter, result)
}

// InsertMany mocks base method.
func (m *MockMongo) InsertMany(ctx context.Context, collection string, documents []any) ([]any, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "InsertMany", ctx, collection, documents)
	ret0, _ := ret[0].([]any)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// InsertMany indicates an expected call of InsertMany.
func (mr *MockMongoMockRecorder) InsertMany(ctx, collection, documents interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "InsertMany", reflect.TypeOf((*MockMongo)(nil).InsertMany), ctx, collection, documents)
}

// InsertOne mocks base method.
func (m *MockMongo) InsertOne(ctx context.Context, collection string, document any) (any, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "InsertOne", ctx, collection, document)
	ret0, _ := ret[0].(any)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// InsertOne indicates an expected call of InsertOne.
func (mr *MockMongoMockRecorder) InsertOne(ctx, collection, document interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "InsertOne", reflect.TypeOf((*MockMongo)(nil).InsertOne), ctx, collection, document)
}

// StartSession mocks base method.
func (m *MockMongo) StartSession() (any, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "StartSession")
	ret0, _ := ret[0].(any)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// StartSession indicates an expected call of StartSession.
func (mr *MockMongoMockRecorder) StartSession() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "StartSession", reflect.TypeOf((*MockMongo)(nil).StartSession))
}

// UpdateByID mocks base method.
func (m *MockMongo) UpdateByID(ctx context.Context, collection string, id, update any) (int64, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "UpdateByID", ctx, collection, id, update)
	ret0, _ := ret[0].(int64)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// UpdateByID indicates an expected call of UpdateByID.
func (mr *MockMongoMockRecorder) UpdateByID(ctx, collection, id, update interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UpdateByID", reflect.TypeOf((*MockMongo)(nil).UpdateByID), ctx, collection, id, update)
}

// UpdateMany mocks base method.
func (m *MockMongo) UpdateMany(ctx context.Context, collection string, filter, update any) (int64, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "UpdateMany", ctx, collection, filter, update)
	ret0, _ := ret[0].(int64)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// UpdateMany indicates an expected call of UpdateMany.
func (mr *MockMongoMockRecorder) UpdateMany(ctx, collection, filter, update interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UpdateMany", reflect.TypeOf((*MockMongo)(nil).UpdateMany), ctx, collection, filter, update)
}

// UpdateOne mocks base method.
func (m *MockMongo) UpdateOne(ctx context.Context, collection string, filter, update any) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "UpdateOne", ctx, collection, filter, update)
	ret0, _ := ret[0].(error)
	return ret0
}

// UpdateOne indicates an expected call of UpdateOne.
func (mr *MockMongoMockRecorder) UpdateOne(ctx, collection, filter, update interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UpdateOne", reflect.TypeOf((*MockMongo)(nil).UpdateOne), ctx, collection, filter, update)
}

// MockArangoDB is a mock of ArangoDB interface.
type MockArangoDB struct {
	ctrl     *gomock.Controller
	recorder *MockArangoDBMockRecorder
}

// MockArangoDBMockRecorder is the mock recorder for MockArangoDB.
type MockArangoDBMockRecorder struct {
	mock *MockArangoDB
}

// NewMockArangoDB creates a new mock instance.
func NewMockArangoDB(ctrl *gomock.Controller) *MockArangoDB {
	mock := &MockArangoDB{ctrl: ctrl}
	mock.recorder = &MockArangoDBMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockArangoDB) EXPECT() *MockArangoDBMockRecorder {
	return m.recorder
}

// CreateCollection mocks base method.
func (m *MockArangoDB) CreateCollection(ctx context.Context, database, collection string, isEdge bool) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CreateCollection", ctx, database, collection, isEdge)
	ret0, _ := ret[0].(error)
	return ret0
}

// CreateCollection indicates an expected call of CreateCollection.
func (mr *MockArangoDBMockRecorder) CreateCollection(ctx, database, collection, isEdge interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CreateCollection", reflect.TypeOf((*MockArangoDB)(nil).CreateCollection), ctx, database, collection, isEdge)
}

// CreateDB mocks base method.
func (m *MockArangoDB) CreateDB(ctx context.Context, database string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CreateDB", ctx, database)
	ret0, _ := ret[0].(error)
	return ret0
}

// CreateDB indicates an expected call of CreateDB.
func (mr *MockArangoDBMockRecorder) CreateDB(ctx, database interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CreateDB", reflect.TypeOf((*MockArangoDB)(nil).CreateDB), ctx, database)
}

// CreateGraph mocks base method.
func (m *MockArangoDB) CreateGraph(ctx context.Context, database, graph string, edgeDefinitions any) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CreateGraph", ctx, database, graph, edgeDefinitions)
	ret0, _ := ret[0].(error)
	return ret0
}

// CreateGraph indicates an expected call of CreateGraph.
func (mr *MockArangoDBMockRecorder) CreateGraph(ctx, database, graph, edgeDefinitions interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CreateGraph", reflect.TypeOf((*MockArangoDB)(nil).CreateGraph), ctx, database, graph, edgeDefinitions)
}

// DropCollection mocks base method.
func (m *MockArangoDB) DropCollection(ctx context.Context, database, collection string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "DropCollection", ctx, database, collection)
	ret0, _ := ret[0].(error)
	return ret0
}

// DropCollection indicates an expected call of DropCollection.
func (mr *MockArangoDBMockRecorder) DropCollection(ctx, database, collection interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DropCollection", reflect.TypeOf((*MockArangoDB)(nil).DropCollection), ctx, database, collection)
}

// DropDB mocks base method.
func (m *MockArangoDB) DropDB(ctx context.Context, database string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "DropDB", ctx, database)
	ret0, _ := ret[0].(error)
	return ret0
}

// DropDB indicates an expected call of DropDB.
func (mr *MockArangoDBMockRecorder) DropDB(ctx, database interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DropDB", reflect.TypeOf((*MockArangoDB)(nil).DropDB), ctx, database)
}

// DropGraph mocks base method.
func (m *MockArangoDB) DropGraph(ctx context.Context, database, graph string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "DropGraph", ctx, database, graph)
	ret0, _ := ret[0].(error)
	return ret0
}

// DropGraph indicates an expected call of DropGraph.
func (mr *MockArangoDBMockRecorder) DropGraph(ctx, database, graph interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DropGraph", reflect.TypeOf((*MockArangoDB)(nil).DropGraph), ctx, database, graph)
}

// MockSurrealDB is a mock of SurrealDB interface.
type MockSurrealDB struct {
	ctrl     *gomock.Controller
	recorder *MockSurrealDBMockRecorder
}

// MockSurrealDBMockRecorder is the mock recorder for MockSurrealDB.
type MockSurrealDBMockRecorder struct {
	mock *MockSurrealDB
}

// NewMockSurrealDB creates a new mock instance.
func NewMockSurrealDB(ctrl *gomock.Controller) *MockSurrealDB {
	mock := &MockSurrealDB{ctrl: ctrl}
	mock.recorder = &MockSurrealDBMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockSurrealDB) EXPECT() *MockSurrealDBMockRecorder {
	return m.recorder
}

// CreateDatabase mocks base method.
func (m *MockSurrealDB) CreateDatabase(ctx context.Context, database string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CreateDatabase", ctx, database)
	ret0, _ := ret[0].(error)
	return ret0
}

// CreateDatabase indicates an expected call of CreateDatabase.
func (mr *MockSurrealDBMockRecorder) CreateDatabase(ctx, database interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CreateDatabase", reflect.TypeOf((*MockSurrealDB)(nil).CreateDatabase), ctx, database)
}

// CreateNamespace mocks base method.
func (m *MockSurrealDB) CreateNamespace(ctx context.Context, namespace string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CreateNamespace", ctx, namespace)
	ret0, _ := ret[0].(error)
	return ret0
}

// CreateNamespace indicates an expected call of CreateNamespace.
func (mr *MockSurrealDBMockRecorder) CreateNamespace(ctx, namespace interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CreateNamespace", reflect.TypeOf((*MockSurrealDB)(nil).CreateNamespace), ctx, namespace)
}

// DropDatabase mocks base method.
func (m *MockSurrealDB) DropDatabase(ctx context.Context, database string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "DropDatabase", ctx, database)
	ret0, _ := ret[0].(error)
	return ret0
}

// DropDatabase indicates an expected call of DropDatabase.
func (mr *MockSurrealDBMockRecorder) DropDatabase(ctx, database interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DropDatabase", reflect.TypeOf((*MockSurrealDB)(nil).DropDatabase), ctx, database)
}

// DropNamespace mocks base method.
func (m *MockSurrealDB) DropNamespace(ctx context.Context, namespace string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "DropNamespace", ctx, namespace)
	ret0, _ := ret[0].(error)
	return ret0
}

// DropNamespace indicates an expected call of DropNamespace.
func (mr *MockSurrealDBMockRecorder) DropNamespace(ctx, namespace interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DropNamespace", reflect.TypeOf((*MockSurrealDB)(nil).DropNamespace), ctx, namespace)
}

// Query mocks base method.
func (m *MockSurrealDB) Query(ctx context.Context, query string, vars map[string]any) ([]any, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Query", ctx, query, vars)
	ret0, _ := ret[0].([]any)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Query indicates an expected call of Query.
func (mr *MockSurrealDBMockRecorder) Query(ctx, query, vars interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Query", reflect.TypeOf((*MockSurrealDB)(nil).Query), ctx, query, vars)
}

// MockDGraph is a mock of DGraph interface.
type MockDGraph struct {
	ctrl     *gomock.Controller
	recorder *MockDGraphMockRecorder
}

// MockDGraphMockRecorder is the mock recorder for MockDGraph.
type MockDGraphMockRecorder struct {
	mock *MockDGraph
}

// NewMockDGraph creates a new mock instance.
func NewMockDGraph(ctrl *gomock.Controller) *MockDGraph {
	mock := &MockDGraph{ctrl: ctrl}
	mock.recorder = &MockDGraphMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockDGraph) EXPECT() *MockDGraphMockRecorder {
	return m.recorder
}

// AddOrUpdateField mocks base method.
func (m *MockDGraph) AddOrUpdateField(ctx context.Context, fieldName, fieldType, directives string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "AddOrUpdateField", ctx, fieldName, fieldType, directives)
	ret0, _ := ret[0].(error)
	return ret0
}

// AddOrUpdateField indicates an expected call of AddOrUpdateField.
func (mr *MockDGraphMockRecorder) AddOrUpdateField(ctx, fieldName, fieldType, directives interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AddOrUpdateField", reflect.TypeOf((*MockDGraph)(nil).AddOrUpdateField), ctx, fieldName, fieldType, directives)
}

// ApplySchema mocks base method.
func (m *MockDGraph) ApplySchema(ctx context.Context, schema string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ApplySchema", ctx, schema)
	ret0, _ := ret[0].(error)
	return ret0
}

// ApplySchema indicates an expected call of ApplySchema.
func (mr *MockDGraphMockRecorder) ApplySchema(ctx, schema interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ApplySchema", reflect.TypeOf((*MockDGraph)(nil).ApplySchema), ctx, schema)
}

// DropField mocks base method.
func (m *MockDGraph) DropField(ctx context.Context, fieldName string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "DropField", ctx, fieldName)
	ret0, _ := ret[0].(error)
	return ret0
}

// DropField indicates an expected call of DropField.
func (mr *MockDGraphMockRecorder) DropField(ctx, fieldName interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DropField", reflect.TypeOf((*MockDGraph)(nil).DropField), ctx, fieldName)
}

// MockScyllaDB is a mock of ScyllaDB interface.
type MockScyllaDB struct {
	ctrl     *gomock.Controller
	recorder *MockScyllaDBMockRecorder
}

// MockScyllaDBMockRecorder is the mock recorder for MockScyllaDB.
type MockScyllaDBMockRecorder struct {
	mock *MockScyllaDB
}

// NewMockScyllaDB creates a new mock instance.
func NewMockScyllaDB(ctrl *gomock.Controller) *MockScyllaDB {
	mock := &MockScyllaDB{ctrl: ctrl}
	mock.recorder = &MockScyllaDBMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockScyllaDB) EXPECT() *MockScyllaDBMockRecorder {
	return m.recorder
}

// BatchQuery mocks base method.
func (m *MockScyllaDB) BatchQuery(name, stmt string, values ...any) error {
	m.ctrl.T.Helper()
	varargs := []interface{}{name, stmt}
	for _, a := range values {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "BatchQuery", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// BatchQuery indicates an expected call of BatchQuery.
func (mr *MockScyllaDBMockRecorder) BatchQuery(name, stmt interface{}, values ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{name, stmt}, values...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "BatchQuery", reflect.TypeOf((*MockScyllaDB)(nil).BatchQuery), varargs...)
}

// BatchQueryWithCtx mocks base method.
func (m *MockScyllaDB) BatchQueryWithCtx(ctx context.Context, name, stmt string, values ...any) error {
	m.ctrl.T.Helper()
	varargs := []interface{}{ctx, name, stmt}
	for _, a := range values {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "BatchQueryWithCtx", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// BatchQueryWithCtx indicates an expected call of BatchQueryWithCtx.
func (mr *MockScyllaDBMockRecorder) BatchQueryWithCtx(ctx, name, stmt interface{}, values ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{ctx, name, stmt}, values...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "BatchQueryWithCtx", reflect.TypeOf((*MockScyllaDB)(nil).BatchQueryWithCtx), varargs...)
}

// Exec mocks base method.
func (m *MockScyllaDB) Exec(stmt string, values ...any) error {
	m.ctrl.T.Helper()
	varargs := []interface{}{stmt}
	for _, a := range values {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Exec", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// Exec indicates an expected call of Exec.
func (mr *MockScyllaDBMockRecorder) Exec(stmt interface{}, values ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{stmt}, values...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Exec", reflect.TypeOf((*MockScyllaDB)(nil).Exec), varargs...)
}

// ExecCAS mocks base method.
func (m *MockScyllaDB) ExecCAS(dest any, stmt string, values ...any) (bool, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{dest, stmt}
	for _, a := range values {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ExecCAS", varargs...)
	ret0, _ := ret[0].(bool)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ExecCAS indicates an expected call of ExecCAS.
func (mr *MockScyllaDBMockRecorder) ExecCAS(dest, stmt interface{}, values ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{dest, stmt}, values...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ExecCAS", reflect.TypeOf((*MockScyllaDB)(nil).ExecCAS), varargs...)
}

// ExecWithCtx mocks base method.
func (m *MockScyllaDB) ExecWithCtx(ctx context.Context, stmt string, values ...any) error {
	m.ctrl.T.Helper()
	varargs := []interface{}{ctx, stmt}
	for _, a := range values {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ExecWithCtx", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// ExecWithCtx indicates an expected call of ExecWithCtx.
func (mr *MockScyllaDBMockRecorder) ExecWithCtx(ctx, stmt interface{}, values ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{ctx, stmt}, values...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ExecWithCtx", reflect.TypeOf((*MockScyllaDB)(nil).ExecWithCtx), varargs...)
}

// ExecuteBatchWithCtx mocks base method.
func (m *MockScyllaDB) ExecuteBatchWithCtx(ctx context.Context, name string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ExecuteBatchWithCtx", ctx, name)
	ret0, _ := ret[0].(error)
	return ret0
}

// ExecuteBatchWithCtx indicates an expected call of ExecuteBatchWithCtx.
func (mr *MockScyllaDBMockRecorder) ExecuteBatchWithCtx(ctx, name interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ExecuteBatchWithCtx", reflect.TypeOf((*MockScyllaDB)(nil).ExecuteBatchWithCtx), ctx, name)
}

// NewBatch mocks base method.
func (m *MockScyllaDB) NewBatch(name string, batchType int) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "NewBatch", name, batchType)
	ret0, _ := ret[0].(error)
	return ret0
}

// NewBatch indicates an expected call of NewBatch.
func (mr *MockScyllaDBMockRecorder) NewBatch(name, batchType interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "NewBatch", reflect.TypeOf((*MockScyllaDB)(nil).NewBatch), name, batchType)
}

// NewBatchWithCtx mocks base method.
func (m *MockScyllaDB) NewBatchWithCtx(ctx context.Context, name string, batchType int) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "NewBatchWithCtx", ctx, name, batchType)
	ret0, _ := ret[0].(error)
	return ret0
}

// NewBatchWithCtx indicates an expected call of NewBatchWithCtx.
func (mr *MockScyllaDBMockRecorder) NewBatchWithCtx(ctx, name, batchType interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "NewBatchWithCtx", reflect.TypeOf((*MockScyllaDB)(nil).NewBatchWithCtx), ctx, name, batchType)
}

// Query mocks base method.
func (m *MockScyllaDB) Query(dest any, stmt string, values ...any) error {
	m.ctrl.T.Helper()
	varargs := []interface{}{dest, stmt}
	for _, a := range values {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Query", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// Query indicates an expected call of Query.
func (mr *MockScyllaDBMockRecorder) Query(dest, stmt interface{}, values ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{dest, stmt}, values...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Query", reflect.TypeOf((*MockScyllaDB)(nil).Query), varargs...)
}

// QueryWithCtx mocks base method.
func (m *MockScyllaDB) QueryWithCtx(ctx context.Context, dest any, stmt string, values ...any) error {
	m.ctrl.T.Helper()
	varargs := []interface{}{ctx, dest, stmt}
	for _, a := range values {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "QueryWithCtx", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// QueryWithCtx indicates an expected call of QueryWithCtx.
func (mr *MockScyllaDBMockRecorder) QueryWithCtx(ctx, dest, stmt interface{}, values ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{ctx, dest, stmt}, values...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "QueryWithCtx", reflect.TypeOf((*MockScyllaDB)(nil).QueryWithCtx), varargs...)
}

// Mockmigrator is a mock of migrator interface.
type Mockmigrator struct {
	ctrl     *gomock.Controller
	recorder *MockmigratorMockRecorder
}

// MockmigratorMockRecorder is the mock recorder for Mockmigrator.
type MockmigratorMockRecorder struct {
	mock *Mockmigrator
}

// NewMockmigrator creates a new mock instance.
func NewMockmigrator(ctrl *gomock.Controller) *Mockmigrator {
	mock := &Mockmigrator{ctrl: ctrl}
	mock.recorder = &MockmigratorMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *Mockmigrator) EXPECT() *MockmigratorMockRecorder {
	return m.recorder
}

// beginTransaction mocks base method.
func (m *Mockmigrator) beginTransaction(c *container.Container) transactionData {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "beginTransaction", c)
	ret0, _ := ret[0].(transactionData)
	return ret0
}

// beginTransaction indicates an expected call of beginTransaction.
func (mr *MockmigratorMockRecorder) beginTransaction(c interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "beginTransaction", reflect.TypeOf((*Mockmigrator)(nil).beginTransaction), c)
}

// checkAndCreateMigrationTable mocks base method.
func (m *Mockmigrator) checkAndCreateMigrationTable(c *container.Container) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "checkAndCreateMigrationTable", c)
	ret0, _ := ret[0].(error)
	return ret0
}

// checkAndCreateMigrationTable indicates an expected call of checkAndCreateMigrationTable.
func (mr *MockmigratorMockRecorder) checkAndCreateMigrationTable(c interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "checkAndCreateMigrationTable", reflect.TypeOf((*Mockmigrator)(nil).checkAndCreateMigrationTable), c)
}

// commitMigration mocks base method.
func (m *Mockmigrator) commitMigration(c *container.Container, data transactionData) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "commitMigration", c, data)
	ret0, _ := ret[0].(error)
	return ret0
}

// commitMigration indicates an expected call of commitMigration.
func (mr *MockmigratorMockRecorder) commitMigration(c, data interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "commitMigration", reflect.TypeOf((*Mockmigrator)(nil).commitMigration), c, data)
}

// getLastMigration mocks base method.
func (m *Mockmigrator) getLastMigration(c *container.Container) int64 {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "getLastMigration", c)
	ret0, _ := ret[0].(int64)
	return ret0
}

// getLastMigration indicates an expected call of getLastMigration.
func (mr *MockmigratorMockRecorder) getLastMigration(c interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "getLastMigration", reflect.TypeOf((*Mockmigrator)(nil).getLastMigration), c)
}

// rollback mocks base method.
func (m *Mockmigrator) rollback(c *container.Container, data transactionData) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "rollback", c, data)
}

// rollback indicates an expected call of rollback.
func (mr *MockmigratorMockRecorder) rollback(c, data interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "rollback", reflect.TypeOf((*Mockmigrator)(nil).rollback), c, data)
}
