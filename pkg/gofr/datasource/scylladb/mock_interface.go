// Code generated by MockGen. DO NOT EDIT.
// Source: interface.go
//
// Generated by this command:
//
//	mockgen -source=interface.go -destination=mock_interface.go -package=scylladb
//

// Package scylladb is a generated GoMock package.
package scylladb

import (
	reflect "reflect"

	gocql "github.com/gocql/gocql"
	gomock "go.uber.org/mock/gomock"
)

// MockclusterConfig is a mock of clusterConfig interface.
type MockclusterConfig struct {
	ctrl     *gomock.Controller
	recorder *MockclusterConfigMockRecorder
	isgomock struct{}
}

// MockclusterConfigMockRecorder is the mock recorder for MockclusterConfig.
type MockclusterConfigMockRecorder struct {
	mock *MockclusterConfig
}

// NewMockclusterConfig creates a new mock instance.
func NewMockclusterConfig(ctrl *gomock.Controller) *MockclusterConfig {
	mock := &MockclusterConfig{ctrl: ctrl}
	mock.recorder = &MockclusterConfigMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockclusterConfig) EXPECT() *MockclusterConfigMockRecorder {
	return m.recorder
}

// createSession mocks base method.
func (m *MockclusterConfig) createSession() (session, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "createSession")
	ret0, _ := ret[0].(session)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// createSession indicates an expected call of createSession.
func (mr *MockclusterConfigMockRecorder) createSession() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "createSession", reflect.TypeOf((*MockclusterConfig)(nil).createSession))
}

// Mockiterator is a mock of iterator interface.
type Mockiterator struct {
	ctrl     *gomock.Controller
	recorder *MockiteratorMockRecorder
	isgomock struct{}
}

// MockiteratorMockRecorder is the mock recorder for Mockiterator.
type MockiteratorMockRecorder struct {
	mock *Mockiterator
}

// NewMockiterator creates a new mock instance.
func NewMockiterator(ctrl *gomock.Controller) *Mockiterator {
	mock := &Mockiterator{ctrl: ctrl}
	mock.recorder = &MockiteratorMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *Mockiterator) EXPECT() *MockiteratorMockRecorder {
	return m.recorder
}

// Columns mocks base method.
func (m *Mockiterator) Columns() []gocql.ColumnInfo {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Columns")
	ret0, _ := ret[0].([]gocql.ColumnInfo)
	return ret0
}

// Columns indicates an expected call of Columns.
func (mr *MockiteratorMockRecorder) Columns() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Columns", reflect.TypeOf((*Mockiterator)(nil).Columns))
}

// NumRows mocks base method.
func (m *Mockiterator) NumRows() int {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "NumRows")
	ret0, _ := ret[0].(int)
	return ret0
}

// NumRows indicates an expected call of NumRows.
func (mr *MockiteratorMockRecorder) NumRows() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "NumRows", reflect.TypeOf((*Mockiterator)(nil).NumRows))
}

// Scan mocks base method.
func (m *Mockiterator) Scan(dest ...any) bool {
	m.ctrl.T.Helper()
	varargs := []any{}
	for _, a := range dest {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Scan", varargs...)
	ret0, _ := ret[0].(bool)
	return ret0
}

// Scan indicates an expected call of Scan.
func (mr *MockiteratorMockRecorder) Scan(dest ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Scan", reflect.TypeOf((*Mockiterator)(nil).Scan), dest...)
}

// Mockquery is a mock of query interface.
type Mockquery struct {
	ctrl     *gomock.Controller
	recorder *MockqueryMockRecorder
	isgomock struct{}
}

// MockqueryMockRecorder is the mock recorder for Mockquery.
type MockqueryMockRecorder struct {
	mock *Mockquery
}

// NewMockquery creates a new mock instance.
func NewMockquery(ctrl *gomock.Controller) *Mockquery {
	mock := &Mockquery{ctrl: ctrl}
	mock.recorder = &MockqueryMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *Mockquery) EXPECT() *MockqueryMockRecorder {
	return m.recorder
}

// Exec mocks base method.
func (m *Mockquery) Exec() error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Exec")
	ret0, _ := ret[0].(error)
	return ret0
}

// Exec indicates an expected call of Exec.
func (mr *MockqueryMockRecorder) Exec() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Exec", reflect.TypeOf((*Mockquery)(nil).Exec))
}

// Iter mocks base method.
func (m *Mockquery) Iter() iterator {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Iter")
	ret0, _ := ret[0].(iterator)
	return ret0
}

// Iter indicates an expected call of Iter.
func (mr *MockqueryMockRecorder) Iter() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Iter", reflect.TypeOf((*Mockquery)(nil).Iter))
}

// MapScanCAS mocks base method.
func (m *Mockquery) MapScanCAS(dest map[string]any) (bool, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "MapScanCAS", dest)
	ret0, _ := ret[0].(bool)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// MapScanCAS indicates an expected call of MapScanCAS.
func (mr *MockqueryMockRecorder) MapScanCAS(dest any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "MapScanCAS", reflect.TypeOf((*Mockquery)(nil).MapScanCAS), dest)
}

// ScanCAS mocks base method.
func (m *Mockquery) ScanCAS(dest ...any) (bool, error) {
	m.ctrl.T.Helper()
	varargs := []any{}
	for _, a := range dest {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ScanCAS", varargs...)
	ret0, _ := ret[0].(bool)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ScanCAS indicates an expected call of ScanCAS.
func (mr *MockqueryMockRecorder) ScanCAS(dest ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ScanCAS", reflect.TypeOf((*Mockquery)(nil).ScanCAS), dest...)
}

// Mockbatch is a mock of batch interface.
type Mockbatch struct {
	ctrl     *gomock.Controller
	recorder *MockbatchMockRecorder
	isgomock struct{}
}

// MockbatchMockRecorder is the mock recorder for Mockbatch.
type MockbatchMockRecorder struct {
	mock *Mockbatch
}

// NewMockbatch creates a new mock instance.
func NewMockbatch(ctrl *gomock.Controller) *Mockbatch {
	mock := &Mockbatch{ctrl: ctrl}
	mock.recorder = &MockbatchMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *Mockbatch) EXPECT() *MockbatchMockRecorder {
	return m.recorder
}

// Query mocks base method.
func (m *Mockbatch) Query(stmt string, args ...any) {
	m.ctrl.T.Helper()
	varargs := []any{stmt}
	for _, a := range args {
		varargs = append(varargs, a)
	}
	m.ctrl.Call(m, "Query", varargs...)
}

// Query indicates an expected call of Query.
func (mr *MockbatchMockRecorder) Query(stmt any, args ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{stmt}, args...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Query", reflect.TypeOf((*Mockbatch)(nil).Query), varargs...)
}

// getBatch mocks base method.
func (m *Mockbatch) getBatch() *gocql.Batch {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "getBatch")
	ret0, _ := ret[0].(*gocql.Batch)
	return ret0
}

// getBatch indicates an expected call of getBatch.
func (mr *MockbatchMockRecorder) getBatch() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "getBatch", reflect.TypeOf((*Mockbatch)(nil).getBatch))
}

// Mocksession is a mock of session interface.
type Mocksession struct {
	ctrl     *gomock.Controller
	recorder *MocksessionMockRecorder
	isgomock struct{}
}

// MocksessionMockRecorder is the mock recorder for Mocksession.
type MocksessionMockRecorder struct {
	mock *Mocksession
}

// NewMocksession creates a new mock instance.
func NewMocksession(ctrl *gomock.Controller) *Mocksession {
	mock := &Mocksession{ctrl: ctrl}
	mock.recorder = &MocksessionMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *Mocksession) EXPECT() *MocksessionMockRecorder {
	return m.recorder
}

// Query mocks base method.
func (m *Mocksession) Query(stmt string, values ...any) query {
	m.ctrl.T.Helper()
	varargs := []any{stmt}
	for _, a := range values {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Query", varargs...)
	ret0, _ := ret[0].(query)
	return ret0
}

// Query indicates an expected call of Query.
func (mr *MocksessionMockRecorder) Query(stmt any, values ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{stmt}, values...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Query", reflect.TypeOf((*Mocksession)(nil).Query), varargs...)
}

// executeBatch mocks base method.
func (m *Mocksession) executeBatch(batch batch) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "executeBatch", batch)
	ret0, _ := ret[0].(error)
	return ret0
}

// executeBatch indicates an expected call of executeBatch.
func (mr *MocksessionMockRecorder) executeBatch(batch any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "executeBatch", reflect.TypeOf((*Mocksession)(nil).executeBatch), batch)
}

// executeBatchCAS mocks base method.
func (m *Mocksession) executeBatchCAS(batch batch, dest ...any) (bool, error) {
	m.ctrl.T.Helper()
	varargs := []any{batch}
	for _, a := range dest {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "executeBatchCAS", varargs...)
	ret0, _ := ret[0].(bool)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// executeBatchCAS indicates an expected call of executeBatchCAS.
func (mr *MocksessionMockRecorder) executeBatchCAS(batch any, dest ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{batch}, dest...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "executeBatchCAS", reflect.TypeOf((*Mocksession)(nil).executeBatchCAS), varargs...)
}

// newBatch mocks base method.
func (m *Mocksession) newBatch(batchType gocql.BatchType) batch {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "newBatch", batchType)
	ret0, _ := ret[0].(batch)
	return ret0
}

// newBatch indicates an expected call of newBatch.
func (mr *MocksessionMockRecorder) newBatch(batchType any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "newBatch", reflect.TypeOf((*Mocksession)(nil).newBatch), batchType)
}
