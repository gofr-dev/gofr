name: Release submodules after GoFr release

# Automatically triggers when a new GoFr tag is published
on:
  release:
    types: [published]   # major / minor release

permissions:
  contents: read
  actions: write

jobs:
  detect-and-dispatch:
    runs-on: ubuntu-latest

    steps:
      # Step 1 — Checkout repository
      - name: Checkout GoFr repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      # Step 2 — Detect current & previous tags
      - name: Identify current & previous tags
        run: |
          CUR_TAG="${{ github.event.release.tag_name }}"
          PREV_TAG=$(git tag --sort=-creatordate | sed -n '2p' || echo "")
          echo "CUR_TAG=$CUR_TAG" >> $GITHUB_ENV
          echo "PREV_TAG=$PREV_TAG" >> $GITHUB_ENV
          echo "Current tag: $CUR_TAG"
          echo "Previous tag: $PREV_TAG"

      # Step 3 — Detect changed files after the previous tag
      - name: Detect changed files since previous tag
        id: changes
        run: |
          if [ -z "$PREV_TAG" ]; then
            echo "No previous tag found — listing all files."
            git ls-tree -r --name-only HEAD > changed.txt
          else
            git diff --name-only "$PREV_TAG" "$CUR_TAG" > changed.txt
          fi
          echo "Changed files:"
          cat changed.txt

      # Step 4 — Map changed directories to submodule repos
      - name: Determine changed submodules
        id: submodules
        run: |
          # Mapping of submodule directories → repository names
          cat > submodule_map.txt << 'EOF'
            pkg/datasources   gofr-dev/datasources
            pkg/logging       gofr-dev/logging
            EOF

          echo "Detecting touched directories..."
          touched_dirs=$(awk -F/ '{print $1"/"$2}' changed.txt | sort -u)

          repos=""
          new_modules=""

          while read -r dir; do
            repo=$(awk -v d="$dir" '$1==d {print $2}' submodule_map.txt)
            if [ -n "$repo" ]; then
              repos="$repos $repo"
            else
              new_modules="$new_modules $dir"
            fi
          done <<< "$touched_dirs"

          echo "repos_to_dispatch=$repos" >> $GITHUB_OUTPUT
          echo "new_modules=$new_modules" >> $GITHUB_OUTPUT

      # Step 5 — DRY RUN: Simulate dispatch for existing modules  
      - name: Trigger dispatch to changed submodules (dry-run)
        if: steps.submodules.outputs.repos_to_dispatch != ''
        run: |
          echo "=== DRY RUN MODE ==="
          for repo in ${{ steps.submodules.outputs.repos_to_dispatch }}; do
            echo "Would trigger dispatch to: $repo (tag: ${{ env.CUR_TAG }})"
          done

      # Step 6 — DRY RUN: Trigger website only for NEW modules
      - name: Trigger website workflow for NEW modules (dry-run)
        if: steps.submodules.outputs.new_modules != ''
        run: |
          echo "=== DRY RUN MODE ==="
          echo "Would trigger website workflow for modules: ${{ steps.submodules.outputs.new_modules }}"
